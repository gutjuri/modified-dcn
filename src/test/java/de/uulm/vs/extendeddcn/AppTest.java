/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.uulm.vs.extendeddcn;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.Test;

import de.uulm.vs.extendeddcn.Dcn.Settings;
import de.uulm.vs.extendeddcn.util.Address;
import de.uulm.vs.extendeddcn.util.Pair;
import de.uulm.vs.extendeddcn.util.Util;

public class AppTest {
  private static Logger LOGGER = LogManager.getLogger();

  @Test
  public void testDcnSendReceiveMessage() throws Exception {
    int n = 3;
    var settings = getSettings(n, false);
    var receivedMessages = Collections.synchronizedSet(new HashSet<byte[]>());
    var msg = "Hello World!".getBytes();

    var runnables = settings.stream().map(setting -> new Runnable() {
      public void run() {
        var dcn = new Dcn(setting);
        try {
          if (setting.getOwnIP().getKey() == 0) {
            LOGGER.debug("Test: Broadcasting now");
            dcn.broadcast(msg);
          }
          LOGGER.debug("Test: Receiving now");
          var recBuf = new byte[msg.length];
          dcn.recv(recBuf);
          receivedMessages.add(recBuf);
          LOGGER.debug("Test: Finished");
        } catch (IOException | InterruptedException e) {
          e.printStackTrace();
        }
        try {
          dcn.shutdown();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      };
    }).collect(Collectors.toList());

    var threads = runnables.stream().map(Thread::new).collect(Collectors.toList());
    threads.forEach(Thread::start);
    threads.forEach(f -> {
      try {
        f.join();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });

    assertTrue(receivedMessages.size() == n);
    for (var msgRec : receivedMessages) {
      assertArrayEquals(msg, msgRec);
    }

  }

  @Test
  public void testDcnSendReceiveShares() throws Exception {
    int n = 3;
    var settings = getSettings(n, true);
    var receivedMessages = Collections.synchronizedMap(new HashMap<Integer, byte[]>());
    var msg = "Hello World!".getBytes();

    var runnables = settings.stream().map(setting -> new Runnable() {
      public void run() {
        var dcn = new Dcn(setting);
        try {
          if (setting.getOwnIP().getKey() == 0) {
            LOGGER.debug("Test: Broadcasting now");
            dcn.broadcast(msg);
          }
          LOGGER.debug("Test: Receiving now");
          var recBuf = dcn.recvShares();
          receivedMessages.putAll(recBuf);
          LOGGER.debug("Test: Finished");
        } catch (IOException | InterruptedException e) {
          e.printStackTrace();
        }
        try {
          dcn.shutdown();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      };
    }).collect(Collectors.toList());

    var threads = runnables.stream().map(Thread::new).collect(Collectors.toList());
    threads.forEach(Thread::start);
    threads.forEach(f -> {
      try {
        f.join();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });

    assertTrue(receivedMessages.size() == n);
    var combined = new ShamirSplitCombine(n, n).combine(receivedMessages);

    // The received shares are padded with zeroes, which we have to account for
    assertTrue(Util.arrayPrefixEquals(combined, msg));

  }

  public static List<Settings> getSettings(int n, boolean sharesOnly) {
    var names = new HashMap<Integer, Address>();
    for (var i = 0; i < n; i++) {
      names.put(i, new Address("127.0.0.1:" + (1337 + i)));
    }

    var settings = names.entrySet().stream().map(entry -> {
      var peers = (HashMap<Integer, Address>) names.clone();
      peers.remove(entry.getKey());
      return new Settings(new Pair<>(entry.getKey(), entry.getValue()), peers,
          sharesOnly ? new HashSet<>() : peers.keySet(),
          sharesOnly ? new HashSet<>() : peers.keySet(), 64, 100, n);
    }).collect(Collectors.toList());

    return settings;
  }

}
